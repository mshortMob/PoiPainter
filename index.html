<html>
	<head>
		<title>FlowMapper</title>
		<style>
			body{
			    margin:0px;    
			}	
			video{
				opacity: 1;
				width:100%;
				height:100%;
				top:0px;
				left:0px;
				z-index:-1;
				transform:scale(-1,1);
				position:fixed;
				float:left;
				object-fit:fill;
			}
		</style>
	</head>
	<body>
		<div id="test">Mouse X: Y:</div>
		<video src="anim1.mp4" autoplay width="128" height="64" id="video1" autoplay loop style="display:none"></video>
		<video src="anim2.mp4" autoplay width="128" height="64" id="video2" autoplay loop style="display:none"></video>
		<video src="anim3.mp4" autoplay width="128" height="64" id="video3" autoplay loop style="display:none"></video>
		<video src="anim4.mp4" autoplay width="128" height="64" id="video4" autoplay loop style="display:none"></video>
		<script src="three.js"></script>
		<script src='dat.gui.min.js'></script>
		<script src="Detector.js"></script>
		<script src="NURBSCurve.js"></script>
		<script src="NURBSSurface.js"></script>
		<script src="NURBSUtils.js"></script>
		<script src="TrackballControls.js"></script>
		<script>
			initGlobalVars();
			function initGlobalVars(){
				addControls();			
				videoTextures=[];
				initVideos();
				points=[];
				container=null;
				camera=null;
				controls=null;
				scene=null;
				renderer=null;
				objects = [];
				displayObjects=[];
				plane = new THREE.Plane();
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				offset = new THREE.Vector3();
				intersection = new THREE.Vector3();
				INTERSECTED=null;
				SELECTED=null;
				initScene();
				animate();
				statesArray=[];
				for(var x=0;x<4;x++){
					var objectJSON ={}
					for (var key in mappingController) {
						objectJSON[key]=mappingController[key]
					}
					statesArray.push(objectJSON)
				}
				for(var y=0;y<4;y++){
					addPlane();
				}
			}
			
			function initScene() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				frustumSize = 1000;
				var aspect = window.innerWidth / window.innerHeight;
				camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 0, 10000 );
				camera.position.z = -1000;
				controls = new THREE.TrackballControls( camera , container);
				controls.enabled=false;
				scene = new THREE.Scene();
				scene.add( new THREE.AmbientLight( 0xffffff ) );
				renderer = new THREE.WebGLRenderer( { antialias: true , alpha:true} );
				renderer.setClearColor( 0x000000 , 1);
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				container.appendChild( renderer.domElement );
				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
				renderer.domElement.addEventListener( 'touchmove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'touchstart', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'touchend', onDocumentMouseUp, false );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			
			function initVideos(){
			  video1      = document.getElementById('video1');
			  videoTexture1 = new THREE.Texture( video1 );
			  videoTexture1.minFilter=THREE.LinearFilter;
			  videoTextures.push(videoTexture1)
			  video2      = document.getElementById('video2');
			  videoTexture2 = new THREE.Texture( video2 );
			  videoTexture2.minFilter=THREE.LinearFilter;
			  videoTextures.push(videoTexture2)
			  video3      = document.getElementById('video3');
			  videoTexture3 = new THREE.Texture( video3 );
			  videoTexture3.minFilter=THREE.LinearFilter;
			  videoTextures.push(videoTexture3)
			  video4      = document.getElementById('video4');
			  videoTexture4 = new THREE.Texture( video4 );
			  videoTexture4.minFilter=THREE.LinearFilter;
			  videoTextures.push(videoTexture4)
			  videoElements=[];
			  videoElements.push(video1)
			  videoElements.push(video2)			  
			  videoElements.push(video3)
			  videoElements.push(video4)
			}
			
			function addControls(){
				globalController  = {
					 selectedFixture:0,
				}
				mappingController  = {
					 Visible:false,
					 ZValue:0,
					 Image:0
				};
				var count=0;
				for(var y=0; y<4;y++){
					for(var x=0; x<4;x++){
						mappingController["VerticeX"+count]=-200+100*x;
						mappingController["VerticeY"+count]=-200+100*y;
						count=count+1;
					}
				}
				gui = new dat.GUI();
				globalFolder=gui.addFolder( "Global" )
				globalFolder.open();
				globalFolder.add(globalController, "selectedFixture", 0, 3, 1 ).onChange(function(){globalController.selectedFixture=parseInt(globalController.selectedFixture);updateControlsView();syncObjectsToJson();});
				gui.width=260;
				controlsFolder=gui.addFolder( "MappingControls" )
				controlsFolder.open();
				controlsFolder.add( mappingController, "Visible", true ).onChange(function(){updateControlsValues();syncObjectsToJson();});	
				controlsFolder.add( mappingController, "ZValue", -20, 20, 1 ).onChange(function(){updateControlsValues();syncObjectsToJson()});
				controlsFolder.add( mappingController, "Image", 0, 3, 1 ).onChange(function(){updateControlsValues();syncObjectsToJson()});
				utilsFolder=gui.addFolder( "Utils" )
				utilsFolder.open();
				utilsFolder.add({ 'Full Screen':function(){ requestFullScreen() }},'Full Screen');
				utilsFolder.add({ 'Save State':function(){ saveState() }},'Save State');
				utilsFolder.add({ 'Recall State':function(){ recallState() }},'Recall State');
			}
									
			function updateControlsView(){
				for (var i in gui.__folders.MappingControls.__controllers) {
					//mappingController[i]=statesArray[globalController.selectedScene].objects[globalController.selectedFixture]
				  mappingController[gui.__folders.MappingControls.__controllers[i].property]=statesArray[parseInt(globalController.selectedFixture)][gui.__folders.MappingControls.__controllers[i].property];

					gui.__folders.MappingControls.__controllers[i].updateDisplay();
				}
			}
			
			function updateControlsValues(){  
				for (var i in gui.__folders.MappingControls.__controllers) {
				  statesArray[parseInt(globalController.selectedFixture)][gui.__folders.MappingControls.__controllers[i].property]=mappingController[gui.__folders.MappingControls.__controllers[i].property];
				}
			}
			
			function syncObjectsToJson(){
				for(var x=0;x<displayObjects.length;x++){
					displayObjects[x].setState(statesArray[x])
					displayObjects[x].hideChildren();
				}
				displayObjects[globalController.selectedFixture].showChildren();
				//changeImageBank();
			}
			
			function addPlane(){
			  function createGeometry(u,v){
					nsControlPoints = [
						 [
							 new THREE.Vector4 ( -200, -200, 0, 1 ),
							 new THREE.Vector4 ( -200, -100, 0, 1 ),
							 new THREE.Vector4 ( -200, 100, 0, 1 ),
							 new THREE.Vector4 ( -200, 200, 0, 1 )
						 ],
						 [
							 new THREE.Vector4 ( 0, -200, 0, 1 ),
							 new THREE.Vector4 ( 0, -100, 0, 1 ),
							 new THREE.Vector4 ( 0, 100, 0, 1 ),
							 new THREE.Vector4 ( 0, 200, 0, 1 )
						 ],
						 [
							 new THREE.Vector4 ( 200, -200, 0, 1 ),
							 new THREE.Vector4 ( 200, -100, 0, 1 ),
							 new THREE.Vector4 ( 200, 100, 0, 1 ),
							 new THREE.Vector4 ( 200, 200, 0, 1 )
						 ]
					 ];
					 degree1 = 2;
					 degree2 = 3;
					 knots1 = [0, 0, 0, 1, 1, 1];
					 knots2 = [0, 0, 0, 0, 1, 1, 1, 1];
					 nurbsSurface = new THREE.NURBSSurface(degree1, degree2, knots1, knots2, nsControlPoints);
					 return nurbsSurface.getPoint(u, v);		
			  }
			  function createObject(){
				var geometry = new THREE.ParametricGeometry( createGeometry, 3, 3 );			  
				//var geometry=new THREE.BoxGeometry( 10, 10, 0 );
				var object = new THREE.Mesh( geometry,new THREE.MeshLambertMaterial({map : videoTextures[0] , morphTargets: true, side: THREE.DoubleSide, transparent:true}));				
			    return object;
			  }
			  var object = createObject();
			  object.showChildren=function(){
					for(var x=0; x<object.children.length ;x++){						
						object.children[x].visible=true;
					}
			  }
			  object.hideChildren=function(){
				for(var x=object.children.length-1;x>=0 ;x--){
						object.children[x].visible=false;			
				}
			  }
			  object.drawV=function(){
				for(var x=0; x<object.geometry.vertices.length ; x++ ){
					var  geo = new THREE.BoxGeometry( 70, 70, 0 );
					var mat = new THREE.PointsMaterial( { size: 300, vertexColors: THREE.VertexColors , color: 0xffffff } );
					var mesh1 = new THREE.Mesh( geo, mat );
					mesh1.name="vertice"+x;
					mesh1.vertNum=x;
					mesh1.position.x=object.geometry.vertices[x].x;
					mesh1.position.y=object.geometry.vertices[x].y;
					mesh1.position.z=-5;
					object.add(mesh1)
					objects.push(mesh1)
				}
			  }
			  object.setState=function(savedJSON){
				object.visible=savedJSON.Visible;
				object.position.z= savedJSON.ZValue
				object.material.map=videoTextures[parseInt(savedJSON.Image)]
				for(var x=0;x<object.geometry.vertices.length;x++){
					object.geometry.vertices[x].x=savedJSON["VerticeX"+x]
					object.geometry.vertices[x].y=savedJSON["VerticeY"+x]
					object.children[x].position.x=savedJSON["VerticeX"+x]
					object.children[x].position.y=savedJSON["VerticeY"+x]
				}
				object.geometry.verticesNeedUpdate = true;			
			  }
			  object.drawV();
			  object.visible=false;
			  scene.add(object);
			  displayObjects.push(object);
			}
									
			function onWindowResize() {
				var aspect = window.innerWidth / window.innerHeight;
				camera.left   = - frustumSize * aspect / 2;
				camera.right  =   frustumSize * aspect / 2;
				camera.top    =   frustumSize / 2;
				camera.bottom = - frustumSize / 2;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function onDocumentMouseMove( event ) {
				//event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2.0 - 1.0;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2.0 + 1.0;
				raycaster.setFromCamera( mouse, camera );
				document.getElementById('test').innerHTML="Mouse X:"+mouse.x+" Y:"+mouse.y
				if (SELECTED) {
					document.getElementById('test').innerHTML="Mouse X:"+mouse.x+" Y:"+mouse.y+"  "+SELECTED.name
				}
				if ( SELECTED ) {
					
					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
						if (SELECTED.name.indexOf('vertice') != -1 && SELECTED.name.indexOf('corner') == -1) {
						    console.log(SELECTED.name)
							SELECTED.position.copy(intersection.sub( offset ));
							SELECTED.parent.geometry.vertices[SELECTED.name.substring(SELECTED.name.indexOf("ce")+2,SELECTED.name.length)].x=SELECTED.position.x;
							SELECTED.parent.geometry.vertices[SELECTED.name.substring(SELECTED.name.indexOf("ce")+2,SELECTED.name.length)].y=SELECTED.position.y;
							SELECTED.parent.geometry.verticesNeedUpdate = true;
							statesArray[parseInt(globalController.selectedFixture)]["VerticeX"+SELECTED.vertNum]=SELECTED.position.x;						
							statesArray[parseInt(globalController.selectedFixture)]["VerticeY"+SELECTED.vertNum]=SELECTED.position.y;			
						}
					}
					return;
				}
				var intersects = raycaster.intersectObjects( objects);
				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						//if ( INTERSECTED ) INTERSECTED.uniforms[0].material.color.setHex( INTERSECTED.currentHex );
						INTERSECTED = intersects[ 0 ].object;
						//INTERSECTED.currentHex = INTERSECTED.uniforms[0].material.color.getHex();
						plane.setFromNormalAndCoplanarPoint(
							camera.getWorldDirection( plane.normal ),
							INTERSECTED.position );
					}
					container.style.cursor = 'pointer';
				} else {
					//if ( INTERSECTED ) INTERSECTED.uniforms[0].material.color.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
					container.style.cursor = 'auto';
				}
			}
			
			function onDocumentMouseDown( event ) {
				//event.preventDefault();
				//requestFullScreen();
				raycaster.setFromCamera( mouse, camera );
				intersects = raycaster.intersectObjects( objects);
				if ( intersects.length > 0 ) {
					SELECTED = intersects[ 0 ].object;
					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
						offset.copy( intersection ).sub( SELECTED.position );
					}
					container.style.cursor = 'move';
				}
			}
			
			function onDocumentMouseUp( event ) {
				//event.preventDefault();
				//SELECTED = null;
				setTimeout(function(){SELECTED = null;},700)
				container.style.cursor = 'auto';
			}
			
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			
			function render() {
				for(var x=0; x<videoTextures.length;x++){
				    if( videoElements[x].readyState === videoElements[x].HAVE_ENOUGH_DATA ){
						videoTextures[x].needsUpdate = true;
					}
				}
				controls.update();
				renderer.render( scene, camera );
			}
			
			function requestFullScreen() {
				// Supports most browsers and their versions.
				var element = document.body; // Make the body go full screen.
				var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
			
				if (requestMethod) { // Native full screen.
					requestMethod.call(element);
				} else if (typeof window.ActiveXObject !== "undefined") { // Older IE.
					var wscript = new ActiveXObject("WScript.Shell");
					if (wscript !== null) {
						wscript.SendKeys("{F11}");
					}
				}
			}
			
			function saveState(){
				var requestBody=JSON.stringify({"storage" : statesArray})
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("POST", "https://5oa8elkgyj.execute-api.us-east-1.amazonaws.com/dev/writeppd", true);
				xmlhttp.send(requestBody);
				xmlhttp.onload = function(e){console.log(xmlhttp.response.status)}
			}
			
			function recallState(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "https://5oa8elkgyj.execute-api.us-east-1.amazonaws.com/dev/writeppd", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					temp=JSON.parse(xmlhttp.response)
					temp=JSON.parse(temp)
					statesArray=temp.storage;
					updateControlsView();
					syncObjectsToJson();
				}
			}
			setTimeout(function(){recallState();},2000)
		</script>
	</body>
</html>

