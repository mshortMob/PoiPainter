<html>
	<head>
		<title>FlowMapper</title>
		<style>
			body{
			    margin:0px;
				background-color:black;
			}	
			video{
				opacity: 1;
				width:100%;
				height:100%;
				top:0px;
				left:0px;
				z-index:-1;
				transform:scale(-1,1);
				position:fixed;
				float:left;
				object-fit:fill;
			}
			canvas{
				opacity: 1;
				width:100%;
				height:100%;
				top:0px;
				left:0px;
				z-index:10;
				transform:scale(1,1);
				position:fixed;
				float:left;
				object-fit:fill;
			}
		</style>
	</head>
	<body>
		<video id="video" autoplay width='256' height='256' style="display:none;"></video>
		<canvas id="canvasp8" autoplay width='256' height='256' style=""></canvas>
		<canvas id="canvasST" autoplay></canvas>
		<script src="jsmpeg.min.js"></script>
		<script src="three.js"></script>
		<script src="pixel8.js"></script>
		<script src='dat.gui.min.js'></script>
		<script src="Detector.js"></script>
		<script src="NURBSSurface.js"></script>
		<script src="NURBSUtils.js"></script>
		<script src="TrackballControls.js"></script>
		<script>
			player = new JSMpeg.Player('ws://192.168.0.86:9999', {
		  		canvas: document.getElementById('canvasST'), disableGl: true
 		   	});
		</script>
<script>

	var container, stats;
	var camera, scene, raycaster, renderer;

	var mouse = new THREE.Vector2(), INTERSECTED;
	var radius = 100, theta = 0;

	init();
	animate();

	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );

		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xf0f0f0 );

		var light = new THREE.DirectionalLight( 0xffffff, 1 );
		light.position.set( 1, 1, 1 ).normalize();
		scene.add( light );

		var geometry = new THREE.BoxBufferGeometry( 20, 20, 20 );

		for ( var i = 0; i < 2000; i ++ ) {

			var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

			object.position.x = Math.random() * 800 - 400;
			object.position.y = Math.random() * 800 - 400;
			object.position.z = Math.random() * 800 - 400;

			object.rotation.x = Math.random() * 2 * Math.PI;
			object.rotation.y = Math.random() * 2 * Math.PI;
			object.rotation.z = Math.random() * 2 * Math.PI;

			object.scale.x = Math.random() + 0.5;
			object.scale.y = Math.random() + 0.5;
			object.scale.z = Math.random() + 0.5;

			scene.add( object );

		}

		raycaster = new THREE.Raycaster();

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );

		//

		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseMove( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

	}

	//

	function animate() {

		requestAnimationFrame( animate );

		render();

	}

	function render() {

		theta += 0.1;

		camera.position.x = radius * Math.sin(( theta/50.0 ) );
		camera.position.y = radius * Math.sin(( theta/50.0 ) );
		camera.position.z = radius * Math.cos(( theta/50.0 ) );
		camera.lookAt( scene.position );

		camera.updateMatrixWorld();

		//find intersections

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( scene.children );

		if ( intersects.length > 0 ) {

			if ( INTERSECTED != intersects[ 0 ].object ) {

				if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

				INTERSECTED = intersects[ 0 ].object;
				INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
				INTERSECTED.material.emissive.setHex( 0xff0000 );

			}

		} else {

			if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

			INTERSECTED = null;

		}

		renderer.render( scene, camera );

	}

</script>

	</body>
</html>

